var ch1 = '\/* fibonacci sequence *\/\n\nvar a = 0, b = 1, f;\n\nfor(var i = 2; i <= 10; i++) {\n        f = a + b;\n        console.log(f);\n        a = b;\n        b = f;\n}\n\n\/* can parse strings to numbers if string contains all numerics *\/\n\nvar ten = parseInt(\"5\") + 5;\nconsole.log(ten);\n\n\/* no runtime error for dividing by 0 *\/\nconsole.log(1 \/ 0);\n\n\/* strings have some helper methods *\/\n\nvar letters = \"abcdefghijklmnopqrstuvwxyz\".length;\nconsole.log(letters + \" letters in the alphabet\");\n\nvar yelloWorld = \"hello, world\".toUpperCase();\nconsole.log(yelloWorld);\nvar sad = \"hello world\".replace(\"hello\", \"goodbye cruel\");\nconsole.log(sad);\n\nvar repeat = sad + \"!\".repeat(3);\nconsole.log(repeat);\n\n\/* string concatenation is done with the + operator *\/\n\nvar concat = \"sharing is \" + \"caring\";\nconsole.log(concat);\n\n\/* can concat strings and numbers to form a string *\/\nconcat += 100;\nconsole.log(concat);\n\n\/* be wary of == versus === *\/\n\nif (123 == \"123\") {\n    console.log(\"why is this a thing?\");\n}    \n\nif (! (123 === \"123\") ) {\n    console.log(\"always use ===\");\n}\n';
var ch2 = '\/* \n    the hoisted function yell can be called, but the shout \n    function declared as a var cannot be called until after \n    its declaration\n*\/\n\nyell(\"frrreeeeeddoooommm\");\n\ntry {\n    shout(\"error\")\n} catch (e) {\n    console.log(e);\n}\n\n\/* one way of declaring a function *\/\n\nvar shout = function(word) {\n    console.log(word.toUpperCase());\n}\n\nshout(\"I\'m on top of the world!\");\n\n\/* this is just the same, except the funciton is hoisted *\/\n\nfunction yell(word) {\n    console.log(word.toUpperCase());\n}\n\nyell(\"boom shaka laka\");\n\n\/* notice how if you pass in something other than a string \n   there is a run time error *\/\n   \ntry {\n    yell(10);\n} catch (e) {\n    console.log(e);\n}\n\n\/* but, you can check the typeof var *\/\n\nvar safeShout = function(word) {\n    if (typeof word === \"string\") {\n        console.log(word.toUpperCase());\n    }\n}\n\nsafeShout(\"this is my safe space\");\nsafeShout(100);\nsafeShout(true);\nsafeShout( { name: \"Jack\", hours: 24 } );\n\n\/* every function has access to the arguments array *\/\n\nfunction questionMany() {\n  for (var i = 0, j = arguments.length; i < j; i++) {\n    console.log(arguments[i] + \"?\");\n  }\n}\n\nquestionMany(\"pineapples\");\nquestionMany(\"o brother\", \"where are thou\", \"constant sorrow\");\n\n\/* you can pass in functions as parameters *\/\n\nvar hooray = function(action) {\n    action(\"hooray\");\n}\n\nhooray(shout);\nhooray(questionMany);\n\n\/* you can also return things, of course *\/\n\nfunction mult(a, b) {\n    return a * b;\n}\n\nconsole.log(mult(3, 7));\n\n\/* you can return functions too! This gets a little complicated and \n    will be covered more in depth in a later chapter *\/\n    \nfunction addN(n) {\n    return function(a) {\n        return a + n;\n    }\n}\n\nvar addSeven = addN(7);\nvar ten = addSeven(3);\n\nconsole.log(ten);\n\nvar addTen = addN(addSeven(3));\nvar twenty = addTen(10);\n\nconsole.log(twenty);\n\n\n\n\n';
var ch3 = '\/* let\'s init an object *\/\n\nvar spaceship = {\n    mass: 22,\n    fuel: 1000,\n    location: {\n        x: 0,\n        y: 0\n    }\n}\n\nconsole.log(\"The spaceship\'s mass is \" + spaceship.mass + \" tons\");\n\n\/* can access the properties like an associative array or hash *\/\n\nfunction checkFuel(ship) {\n    if (ship[\"fuel\"] < 150) {\n        console.log(\"Danger, low on fuel!\");\n    } else {\n        console.log(\"All good on fuel.\");\n    }\n    console.log(ship[\"fuel\"] + \" gallons of fuel left\");\n}\n\ncheckFuel(spaceship);\n\n\/* you can add properties on the fly *\/\n\nspaceship.name = \"Apollo 13\";\nspaceship.mpg = 533;\n\nconsole.log(spaceship.name + \" gets \" + spaceship.mpg + \n            \" miles to the gallon \");\n\n\/* you can use the this keyword to access the object\'s properties\n   if the function is called within the context of the object *\/\n\nspaceship.fly = function(x, y) {\n\n    this.location.x += x;\n    this.location.y += y;\n        \n    this.fuel -= x \/ this.mpg;\n    this.fuel -= y \/ this.mpg;\n}\n\nspaceship.fly(200000, 300000);\ncheckFuel(spaceship);\n\n\/* you can have vars act as references to other objects *\/\n\nvar a = { num: 100 }\nvar b = a;\n\nb.num = 9;\n\nconsole.log(a.num);\n\n\n';
var ch4 = 'var bag = [\"cola\", \"sandwich\", \"cake\", \"lamp\"];\n\nfunction question(item) {\n    console.log(\"i love \" + item + \"?\");\n}\n\nbag.forEach(question);\n\n\/* replace an item *\/\n\nbag[0] = \"fanta\"\n\nconsole.log(bag[0]);\n\n\/* accessing an element that does not exist will return undefined *\/\n\nconsole.log(typeof bag[99]);\n\n\/* and you can insert into the array anywhere you please, if the index\n   is beyond the length of your array, undefined objects will \n   be created *\/\n\nbag[10] = \"baseball\";\n\nconsole.log(bag);\nconsole.log(typeof bag[7]);\n\n\/* arrays can behave as stacks *\/\n\nvar pez = [];\n\npez.push(\"cherry\");\npez.push(\"grape\");\npez.push(\"lemon\");\npez.push(\"mango\");\n\nconsole.log(pez.pop());\nconsole.log(pez.toString());\n\n\n\/* map function is like for each, except it returns an array so \n   you can chain calls *\/\n\nvar garage = [\"beamer\", \"benz\", \"bentley\"];\n\nfunction drive(car) {\n    console.log(\"driving \" + car);\n}\n\nfunction formal(car) {\n    if (car == \"beamer\") {\n        return \"BMW\";\n    } else if (car == \"benz\") {\n        return \"Mercedes\";\n    } else {\n        return \"Bentley\";\n    }\n}\n\n\/* chaining functions *\/\ngarage.map(formal).forEach(drive);\n\n\/* doesnt work like this *\/\ntry {\n    garage.forEach(formal).forEach(drive);\n} catch (e) {\n    console.log(e);\n}\n\n\/* does not change original array *\/\nconsole.log(garage);\n\n\/* reduce is also hepful and is commonly used to sum an array *\/\n\nvar nums = [1, 3, 5, 8];\n\nfunction sum(runningSum, num) {\n    return runningSum + num;\n}\n\nvar total = nums.reduce(sum);\nconsole.log(total);\n\nfunction sumSquares(runningSum, num) {\n    return runningSum += num * num;\n}\n\ntotal = nums.reduce(sumSquares);\nconsole.log(total);\n\nfunction sumOddOnly(runningSum, num) {\n    if (num % 2 == 1) {\n        return runningSum += num;\n    }\n    return runningSum;\n}\n\ntotal = nums.reduce(sumOddOnly);\nconsole.log(total);\n\n\/* can use the filter or map function and reduce together to recreate the \n   last two examples *\/\n\nfunction square(num) {\n    return num * num;\n}\n\ntotal = nums.map(square).reduce(sum);\nconsole.log(total);\n\nfunction isOdd(num) {\n    return num % 2 == 1;\n}\n\ntotal = nums.filter(isOdd).reduce(sum);\nconsole.log(total);\n\n\n';
var ch6 = '\/* equality in javascript is funny *\/\n\nif (4 == \"4\") {\n  var sameAs = (4 === parseInt(\"4\"));\n  console.log(sameAs);\n}\n\nif (true == \'1\') {\n    var sameAs = (1 === parseInt(\'1\'));\n    console.log(sameAs);\n}\n\nif ( 0 == false ) {\n    var sameAs = (0 === 0);\n    console.log(sameAs);\n}\n\n\/* this prints \'false\' because 0 and false are different types *\/\nconsole.log(0 === false);\n\n\n\/* functions *\/\n\nvar a = 88;\n\n\/* this is run immediately and has its own scope,\n does not pollute global namespace *\/\n(function (){\n    var a = 2;\n    console.log(\"first\");\n}());\n\nconsole.log(\"second\");\nconsole.log(a);\n\nvar nums = [1, 2, 3];\nfunction square(val) {\n  return val * val;\n}\n\n\/* old way *\/\nvar squared1 = nums.map(square);\n\n\/* function declared inline *\/\nvar squared2 = nums.map(function(n) {\n  return n * n;\n});\n\nconsole.log(squared1.toString());\nconsole.log(squared1.toString());\n\n\n\/* closures *\/\n\n\/* each instance of the function has it\'s own set of variables *\/\n\nfunction counter() {\n    var count = 0;\n    return function() {\n        console.log(count++);\n    }\n}\nvar juan = {}, tew = {};\njuan.count = counter();\ntew.count = counter();\njuan.count();  \/\/ \"0\"\njuan.count();  \/\/ \"1\"\ntew.count();   \/\/ \"0\"\ntew.count();   \/\/ \"1\"';
var ch7 = '\/\/ Expression bodies\nvar evens = [2, 4, 6, 8];\nvar odds = evens.map(v => v + 1);\nvar nums = evens.map((v, i) => v + i);\nvar pairs = evens.map(v => ({even: v, odd: v + 1}));\n\nvar fives = [];\n\n\/\/ Statement bodies\nnums.forEach(v => {\n  if (v % 5 === 0) {\n    fives.push(v);\n  }\n});\n\n\/\/ Lexical this\nvar bob = {\n  _name: \"Bob\",\n  _friends: [\"Jo\", \"Mark\", \"Harry\"],\n  printFriends() {\n    this._friends.forEach(f =>\n      \/\/ \'this\' refers to bob\n      console.log(this._name + \" knows \" + f));\n  },\n  badPrintFriends() {\n    this._friends.forEach(function(f) {\n        \/\/ \'this\' refers to global object window\n      console.log(this._name + \" knows \" + f);\n    });\n  }\n}\n\nbob.printFriends();\nbob.badPrintFriends();\n\nconsole.log(\"Evens: \" + evens);\nconsole.log(\"Odds: \" + odds);\nconsole.log(\"Nums: \" + nums);\n\nconsole.log(\"Pairs:\" )\n\nfor (let i = 0; i < pairs.length; i++ ) {\n    console.log(pairs[i].even + \", \" + pairs[i].odd);\n}\n\nconsole.log(\"Fives:\" + fives);\n\n\/\/ parameters\n\nfunction f (x, y = 7, z = 42) {\n    return x + y + z\n}\n\nfunction g(x, y, ...a) {\n    return (x + y) * a.length\n}\n\nfunction h(x, y, z) {\n  return x + y + z;\n}\n\nconsole.log(f(1));                          \/\/ 50\nconsole.log(g(1, 2, \"hello\", true, 7));     \/\/ 9\nconsole.log(h(...[1,2,3]));                 \/\/ 6\n\n\n\n\n\n\n';

$('#ch0').click(function () {
	editor.setValue(ch0, -1);
});

$('#ch1').click(function () {
	editor.setValue(ch1, -1);
});

$('#ch2').click(function () {
	editor.setValue(ch2, -1);
});

$('#ch3').click(function () {
	editor.setValue(ch3, -1);
});

$('#ch4').click(function () {
	editor.setValue(ch4, -1);
});

$('#ch5').click(function () {
	editor.setValue(ch5, -1);
});

$('#ch6').click(function () {
	editor.setValue(ch6, -1);
});

$('#ch7').click(function () {
	editor.setValue(ch7, -1);
});